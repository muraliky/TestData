#!/usr/bin/env node
/**
 * Script 05: Generate fixtures.ts
 * - Scans all generated page classes
 * - Creates fixtures.ts with all imports and page fixtures
 * 
 * Usage: node scripts/05-generate-fixtures.js <config-path>
 * Example: node scripts/05-generate-fixtures.js ./migration-config.json
 */

const fs = require('fs');
const path = require('path');

// Get config path from arguments
const configPath = process.argv[2] || './migration-config.json';

console.log('='.repeat(60));
console.log('  SCRIPT 05: FIXTURES GENERATION');
console.log('='.repeat(60));

// Load configuration
if (!fs.existsSync(configPath)) {
  console.log('\n[ERROR] Configuration file not found: ' + configPath);
  console.log('\nUsage: node scripts/05-generate-fixtures.js <config-path>');
  process.exit(1);
}

let config;
try {
  const content = fs.readFileSync(configPath, 'utf8');
  const cleanContent = content.replace(/"\/\/[^"]*":\s*"[^"]*",?\s*/g, '');
  config = JSON.parse(cleanContent);
} catch (err) {
  console.log('\n[ERROR] Failed to parse configuration: ' + err.message);
  process.exit(1);
}

// Build paths from config
const targetRoot = config.target.rootDir;
const targetPagesPath = config.target.pages || 'src/pages';
const targetFixturesPath = config.target.fixtures || 'src/steps/fixtures.ts';

const pagesDir = path.join(targetRoot, targetPagesPath);
const outputFile = path.join(targetRoot, targetFixturesPath);

console.log('\n[INFO] Configuration loaded');
console.log('  Pages directory: ' + pagesDir);
console.log('  Output file: ' + outputFile);

// Validate pages directory exists
if (!fs.existsSync(pagesDir)) {
  console.log('\n[ERROR] Pages directory not found: ' + pagesDir);
  console.log('  Please run script 03 first to generate page classes');
  process.exit(1);
}

const pageClasses = [];

// Recursively find all page classes
function findPageClasses(dir, relativePath = '') {
  if (!fs.existsSync(dir)) {
    return;
  }
  
  const items = fs.readdirSync(dir);
  
  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);
    
    if (stats.isDirectory()) {
      findPageClasses(fullPath, path.join(relativePath, item));
    } else if (item.endsWith('.page.ts') && item !== 'base.page.ts') {
      // Read file to extract class name
      const content = fs.readFileSync(fullPath, 'utf8');
      const classMatch = content.match(/export\s+class\s+(\w+)/);
      
      if (classMatch) {
        const className = classMatch[1];
        const importPath = path.join(relativePath, item.replace('.ts', '')).replace(/\\/g, '/');
        
        // Generate fixture name: AccountsPage -> accountsPage
        const fixtureName = className.charAt(0).toLowerCase() + className.slice(1);
        
        pageClasses.push({
          className: className,
          fixtureName: fixtureName,
          importPath: importPath,
          filePath: fullPath
        });
        
        console.log('  [FOUND] ' + className + ' -> ' + fixtureName);
      }
    }
  });
}

console.log('\n[INFO] Scanning page classes...\n');
findPageClasses(pagesDir);

if (pageClasses.length === 0) {
  console.log('\n[WARNING] No page classes found in: ' + pagesDir);
  console.log('  Please run script 03 first to generate page classes');
}

// Sort by class name
pageClasses.sort((a, b) => a.className.localeCompare(b.className));

// Generate imports
const imports = pageClasses.map(pc => {
  return "import { " + pc.className + " } from '../pages/" + pc.importPath + "';";
}).join('\n');

// Generate type definition
const typeProps = pageClasses.map(pc => {
  return '  ' + pc.fixtureName + ': ' + pc.className + ';';
}).join('\n');

// Generate fixtures
const fixtureProps = pageClasses.map(pc => {
  return '  ' + pc.fixtureName + ': async ({ page }, use) => {\n    await use(new ' + pc.className + '(page));\n  },';
}).join('\n\n');

// Generate full fixtures.ts content
const fixturesContent = `/**
 * Playwright-BDD Fixtures
 * Auto-generated by migration script
 * Generated: ${new Date().toISOString()}
 * 
 * Total page fixtures: ${pageClasses.length}
 */
import { test as base, createBdd } from 'playwright-bdd';

// Page imports
${imports || '// No page classes found'}

// Type definition for all page fixtures
type PageFixtures = {
${typeProps || '  // No fixtures defined'}
};

// Extend base test with page fixtures
export const test = base.extend<PageFixtures>({
${fixtureProps || '  // No fixtures defined'}
});

// Before each test hook
test.beforeEach(async ({ page, context }, testInfo) => {
  console.log('Starting test: ' + testInfo.title);
  await context.clearCookies();
  page.setDefaultTimeout(30000);
});

// After each test hook
test.afterEach(async ({ page }, testInfo) => {
  if (testInfo.status !== 'passed') {
    const screenshotName = testInfo.title.replace(/[^a-zA-Z0-9]/g, '_');
    await page.screenshot({
      path: 'screenshots/' + screenshotName + '-' + Date.now() + '.png',
      fullPage: true
    });
    console.log('Screenshot saved for failed test');
  }
  console.log('Finished test: ' + testInfo.title + ' - ' + testInfo.status);
});

// Create BDD functions
export const { Given, When, Then } = createBdd(test);

// Re-export expect for assertions
export { expect } from '@playwright/test';
`;

// Ensure output directory exists
const outputDir = path.dirname(outputFile);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Write fixtures.ts
fs.writeFileSync(outputFile, fixturesContent);

// Summary
console.log('\n' + '='.repeat(60));
console.log('  GENERATION COMPLETE');
console.log('='.repeat(60));
console.log('\nSummary:');
console.log('  Page fixtures generated: ' + pageClasses.length);
console.log('  Output file: ' + outputFile);

console.log('\nNext steps:');
console.log('  1. Review the generated fixtures.ts');
console.log('  2. Run: node scripts/06-migration-report.js ' + configPath);
console.log('  3. Run: npm install && npx bddgen');
console.log('  4. Run: npm test');
